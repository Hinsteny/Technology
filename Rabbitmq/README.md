# RabbitMQ 特性收集
在使用RMQ时, 需要了解它的相关特性以便更好的辅助自己的业务;

### 消息丢失
1. 声明QUEUE时指定 [durable=True]: 防止MQ server退出, 重启, 崩溃时丢失消息队列中还未被消费的消息内容, 特殊[声明queue时不能重复用不同的参数去创建同名的queue,
    比如已经声明一个queue的数据不进行持久化了, 那再用持久化的参数去覆盖对它的声明, 就是无效的, 返回错误];
2. 发布消息时指定消息需要被持久化保存 [delivery_mode=2]: 这样在server收到生产者发送来的消息时就会进行持久化存储, 这一点足以满足大多数的消息系统了;
    但是由于server对消息的持久化处理, 当它收到消息时首先会放到缓存中, 并不是第一时间就马上进行存储, 所以为了更安全的保证发布的消息会被持久化, 可以在生产者发送消息时声明需要接收反馈[Publisher Confirms];
3. 合理的派发消息[prefetch_count=1]: 有时候可能由于不同的work消费消息的能力不同, 如果默认的平均分发机制, 可能会导致某个work一直高负荷的工作而其他一些work又很空闲, 这样一个是资源利用不合理更是导致消息处理的不及时;
    这时结合消费回馈机制我们可以设置每个work设置它的当前消息消费数, 如果它还没有执行完正在消费的消息, 就不会给它再派发消息了;

### 订阅模式
1. 首先声明一个fanout类型的exchange, 然后生产者往该路由器发送消息, 其次在消费者端声明一个queue并与指定wxchange进行绑定, 订阅模式下, exchange 端的routing_key与queue绑定exchange时指定的routing_key都是没用的,
    被发送到exchange的消息会被广播到所有与该路由器绑定的queue中嗒

### 路由模式
1. 首先声明一个direct类型的exchange, 然后生产者往该路由器发送消息的时候需要提供一个routing_key, 指定该消息的转发路线, 然后再消费者一端, 在绑定queue与exchange的关系时同时需要指定一个routing_key,
    表示该queue对那些类型的消息感兴趣[绑定关系可以声明多个]; 这样当一个消息待着表示的bouting_key被发送到exchange时, 然后它只会被exchange转发到对有绑定一致routing_key的queue里面去;

### 主题模式
1. 与路由模式不同的地方就是exchange的类型是topic,随后在发送与绑定queue时可以通过匹配符[#,*]去适配更多的routing_key, 从而可以从queue端获得更灵活的消息类型;

### RPC模式


